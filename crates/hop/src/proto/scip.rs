// This file is @generated by prost-build.
/// Index represents a complete SCIP index for a workspace this is rooted at a
/// single directory. An Index message payload can have a large memory footprint
/// and it's therefore recommended to emit and consume an Index payload one field
/// value at a time. To permit streaming consumption of an Index payload, the
/// `metadata` field must appear at the start of the stream and must only appear
/// once in the stream. Other field values may appear in any order.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Index {
    /// Metadata about this index.
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<Metadata>,
    /// Documents that belong to this index.
    #[prost(message, repeated, tag = "2")]
    pub documents: ::prost::alloc::vec::Vec<Document>,
    /// (optional) Symbols that are referenced from this index but are defined in
    /// an external package (a separate `Index` message). Leave this field empty
    /// if you assume the external package will get indexed separately. If the
    /// external package won't get indexed for some reason then you can use this
    /// field to provide hover documentation for those external symbols.
    ///
    /// IMPORTANT: When adding a new field to `Index` here, add a matching
    /// function in `IndexVisitor` and update `ParseStreaming`.
    #[prost(message, repeated, tag = "3")]
    pub external_symbols: ::prost::alloc::vec::Vec<SymbolInformation>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Metadata {
    /// Which version of this protocol was used to generate this index?
    #[prost(enumeration = "ProtocolVersion", tag = "1")]
    pub version: i32,
    /// Information about the tool that produced this index.
    #[prost(message, optional, tag = "2")]
    pub tool_info: ::core::option::Option<ToolInfo>,
    /// URI-encoded absolute path to the root directory of this index. All
    /// documents in this index must appear in a subdirectory of this root
    /// directory.
    #[prost(string, tag = "3")]
    pub project_root: ::prost::alloc::string::String,
    /// Text encoding of the source files on disk that are referenced from
    /// `Document.relative_path`. This value is unrelated to the `Document.text`
    /// field, which is a Protobuf string and hence must be UTF-8 encoded.
    #[prost(enumeration = "TextEncoding", tag = "4")]
    pub text_document_encoding: i32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ToolInfo {
    /// Name of the indexer that produced this index.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Version of the indexer that produced this index.
    #[prost(string, tag = "2")]
    pub version: ::prost::alloc::string::String,
    /// Command-line arguments that were used to invoke this indexer.
    #[prost(string, repeated, tag = "3")]
    pub arguments: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Document defines the metadata about a source file on disk.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Document {
    /// The string ID for the programming language this file is written in.
    /// The `Language` enum contains the names of most common programming languages.
    /// This field is typed as a string to permit any programming language, including
    /// ones that are not specified by the `Language` enum.
    #[prost(string, tag = "4")]
    pub language: ::prost::alloc::string::String,
    /// (Required) Unique path to the text document.
    ///
    /// 1. The path must be relative to the directory supplied in the associated
    ///     `Metadata.project_root`.
    /// 2. The path must not begin with a leading '/'.
    /// 3. The path must point to a regular file, not a symbolic link.
    /// 4. The path must use '/' as the separator, including on Windows.
    /// 5. The path must be canonical; it cannot include empty components ('//'),
    ///     or '.' or '..'.
    #[prost(string, tag = "1")]
    pub relative_path: ::prost::alloc::string::String,
    /// Occurrences that appear in this file.
    #[prost(message, repeated, tag = "2")]
    pub occurrences: ::prost::alloc::vec::Vec<Occurrence>,
    /// Symbols that are "defined" within this document.
    ///
    /// This should include symbols which technically do not have any definition,
    /// but have a reference and are defined by some other symbol (see
    /// Relationship.is_definition).
    #[prost(message, repeated, tag = "3")]
    pub symbols: ::prost::alloc::vec::Vec<SymbolInformation>,
    /// (optional) Text contents of the this document. Indexers are not expected to
    /// include the text by default. It's preferrable that clients read the text
    /// contents from the file system by resolving the absolute path from joining
    /// `Index.metadata.project_root` and `Document.relative_path`. This field was
    /// introduced to support `SymbolInformation.signature_documentation`, but it
    /// can be used for other purposes as well, for example testing or when working
    /// with virtual/in-memory documents.
    #[prost(string, tag = "5")]
    pub text: ::prost::alloc::string::String,
    /// Specifies the encoding used for source ranges in this Document.
    ///
    /// Usually, this will match the type used to index the string type
    /// in the indexer's implementation language in O(1) time.
    /// - For an indexer implemented in JVM/.NET language or JavaScript/TypeScript,
    ///    use UTF16CodeUnitOffsetFromLineStart.
    /// - For an indexer implemented in Python,
    ///    use UTF32CodeUnitOffsetFromLineStart.
    /// - For an indexer implemented in Go, Rust or C++,
    ///    use UTF8ByteOffsetFromLineStart.
    #[prost(enumeration = "PositionEncoding", tag = "6")]
    pub position_encoding: i32,
}
/// Symbol is similar to a URI, it identifies a class, method, or a local
/// variable. `SymbolInformation` contains rich metadata about symbols such as
/// the docstring.
///
/// Symbol has a standardized string representation, which can be used
/// interchangeably with `Symbol`. The syntax for Symbol is the following:
/// ```
/// # (<x>)+ stands for one or more repetitions of <x>
/// # (<x>)? stands for zero or one occurrence of <x>
/// <symbol>               ::= <scheme> ' ' <package> ' ' (<descriptor>)+ | 'local ' <local-id>
/// <package>              ::= <manager> ' ' <package-name> ' ' <version>
/// <scheme>               ::= any UTF-8, escape spaces with double space. Must not be empty nor start with 'local'
/// <manager>              ::= any UTF-8, escape spaces with double space. Use the placeholder '.' to indicate an empty value
/// <package-name>         ::= same as above
/// <version>              ::= same as above
/// <descriptor>           ::= <namespace> | <type> | <term> | <method> | <type-parameter> | <parameter> | <meta> | <macro>
/// <namespace>            ::= <name> '/'
/// <type>                 ::= <name> '#'
/// <term>                 ::= <name> '.'
/// <meta>                 ::= <name> ':'
/// <macro>                ::= <name> '!'
/// <method>               ::= <name> '(' (<method-disambiguator>)? ').'
/// <type-parameter>       ::= '\[' <name> '\]'
/// <parameter>            ::= '(' <name> ')'
/// <name>                 ::= <identifier>
/// <method-disambiguator> ::= <simple-identifier>
/// <identifier>           ::= <simple-identifier> | <escaped-identifier>
/// <simple-identifier>    ::= (<identifier-character>)+
/// <identifier-character> ::= '_' | '+' | '-' | '$' | ASCII letter or digit
/// <escaped-identifier>   ::= '`' (<escaped-character>)+ '`', must contain at least one non-<identifier-character>
/// <escaped-characters>   ::= any UTF-8, escape backticks with double backtick.
/// <local-id>             ::= <simple-identifier>
/// ```
///
/// The list of descriptors for a symbol should together form a fully
/// qualified name for the symbol. That is, it should serve as a unique
/// identifier across the package. Typically, it will include one descriptor
/// for every node in the AST (along the ancestry path) between the root of
/// the file and the node corresponding to the symbol.
///
/// Local symbols MUST only be used for entities which are local to a Document,
/// and cannot be accessed from outside the Document.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Symbol {
    #[prost(string, tag = "1")]
    pub scheme: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub package: ::core::option::Option<Package>,
    #[prost(message, repeated, tag = "3")]
    pub descriptors: ::prost::alloc::vec::Vec<Descriptor>,
}
/// Unit of packaging and distribution.
///
/// NOTE: This corresponds to a module in Go and JVM languages.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Package {
    #[prost(string, tag = "1")]
    pub manager: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub version: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Descriptor {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub disambiguator: ::prost::alloc::string::String,
    #[prost(enumeration = "descriptor::Suffix", tag = "3")]
    pub suffix: i32,
}
/// Nested message and enum types in `Descriptor`.
pub mod descriptor {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Suffix {
        UnspecifiedSuffix = 0,
        /// Unit of code abstraction and/or namespacing.
        ///
        /// NOTE: This corresponds to a package in Go and JVM languages.
        Namespace = 1,
        Type = 2,
        Term = 3,
        Method = 4,
        TypeParameter = 5,
        Parameter = 6,
        /// Can be used for any purpose.
        Meta = 7,
        Local = 8,
        Macro = 9,
    }
    impl Suffix {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Suffix::UnspecifiedSuffix => "UnspecifiedSuffix",
                Suffix::Namespace => "Namespace",
                Suffix::Type => "Type",
                Suffix::Term => "Term",
                Suffix::Method => "Method",
                Suffix::TypeParameter => "TypeParameter",
                Suffix::Parameter => "Parameter",
                Suffix::Meta => "Meta",
                Suffix::Local => "Local",
                Suffix::Macro => "Macro",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UnspecifiedSuffix" => Some(Self::UnspecifiedSuffix),
                "Namespace" => Some(Self::Namespace),
                "Type" => Some(Self::Type),
                "Term" => Some(Self::Term),
                "Method" => Some(Self::Method),
                "TypeParameter" => Some(Self::TypeParameter),
                "Parameter" => Some(Self::Parameter),
                "Meta" => Some(Self::Meta),
                "Local" => Some(Self::Local),
                "Macro" => Some(Self::Macro),
                _ => None,
            }
        }
    }
}
/// SymbolInformation defines metadata about a symbol, such as the symbol's
/// docstring or what package it's defined it.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SymbolInformation {
    /// Identifier of this symbol, which can be referenced from `Occurence.symbol`.
    /// The string must be formatted according to the grammar in `Symbol`.
    #[prost(string, tag = "1")]
    pub symbol: ::prost::alloc::string::String,
    /// (optional, but strongly recommended) The markdown-formatted documentation
    /// for this symbol. Use `SymbolInformation.signature_documentation` to
    /// document the method/class/type signature of this symbol.
    /// Due to historical reasons, indexers may include signature documentation in
    /// this field by rendering markdown code blocks. New indexers should only
    /// include non-code documentation in this field, for example docstrings.
    #[prost(string, repeated, tag = "3")]
    pub documentation: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// (optional) Relationships to other symbols (e.g., implements, type definition).
    #[prost(message, repeated, tag = "4")]
    pub relationships: ::prost::alloc::vec::Vec<Relationship>,
    /// The kind of this symbol. Use this field instead of
    /// `SymbolDescriptor.Suffix` to determine whether something is, for example, a
    /// class or a method.
    #[prost(enumeration = "symbol_information::Kind", tag = "5")]
    pub kind: i32,
    /// (optional) The name of this symbol as it should be displayed to the user.
    /// For example, the symbol "com/example/MyClass#myMethod(+1)." should have the
    /// display name "myMethod". The `symbol` field is not a reliable source of
    /// the display name for several reasons:
    ///
    /// - Local symbols don't encode the name.
    /// - Some languages have case-insensitive names, so the symbol is all-lowercase.
    /// - The symbol may encode names with special characters that should not be
    ///    displayed to the user.
    #[prost(string, tag = "6")]
    pub display_name: ::prost::alloc::string::String,
    /// (optional) The signature of this symbol as it's displayed in API
    /// documentation or in hover tooltips. For example, a Java method that adds
    /// two numbers this would have `Document.language = "java"` and `Document.text
    /// = "void add(int a, int b)". The `language` and `text` fields are required
    /// while other fields such as `Documentation.occurrences` can be optionally
    /// included to support hyperlinking referenced symbols in the signature.
    #[prost(message, optional, tag = "7")]
    pub signature_documentation: ::core::option::Option<Document>,
    /// (optional) The enclosing symbol if this is a local symbol.  For non-local
    /// symbols, the enclosing symbol should be parsed from the `symbol` field
    /// using the `Descriptor` grammar.
    ///
    /// The primary use-case for this field is to allow local symbol to be displayed
    /// in a symbol hierarchy for API documentation. It's OK to leave this field
    /// empty for local variables since local variables usually don't belong in API
    /// documentation. However, in the situation that you wish to include a local
    /// symbol in the hierarchy, then you can use `enclosing_symbol` to locate the
    /// "parent" or "owner" of this local symbol. For example, a Java indexer may
    /// choose to use local symbols for private class fields while providing an
    /// `enclosing_symbol` to reference the enclosing class to allow the field to
    /// be part of the class documentation hierarchy. From the perspective of an
    /// author of an indexer, the decision to use a local symbol or global symbol
    /// should exclusively be determined whether the local symbol is accessible
    /// outside the document, not by the capability to find the enclosing
    /// symbol.
    #[prost(string, tag = "8")]
    pub enclosing_symbol: ::prost::alloc::string::String,
}
/// Nested message and enum types in `SymbolInformation`.
pub mod symbol_information {
    /// (optional) Kind represents the fine-grained category of a symbol, suitable for presenting
    /// information about the symbol's meaning in the language.
    ///
    /// For example:
    /// - A Java method would have the kind `Method` while a Go function would
    ///    have the kind `Function`, even if the symbols for these use the same
    ///    syntax for the descriptor `SymbolDescriptor.Suffix.Method`.
    /// - A Go struct has the symbol kind `Struct` while a Java class has
    ///    the symbol kind `Class` even if they both have the same descriptor:
    ///    `SymbolDescriptor.Suffix.Type`.
    ///
    /// Since Kind is more fine-grained than Suffix:
    /// - If two symbols have the same Kind, they should share the same Suffix.
    /// - If two symbols have different Suffixes, they should have different Kinds.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Kind {
        UnspecifiedKind = 0,
        /// A method which may or may not have a body. For Java, Kotlin etc.
        AbstractMethod = 66,
        /// For Ruby's attr_accessor
        Accessor = 72,
        Array = 1,
        /// For Alloy
        Assertion = 2,
        AssociatedType = 3,
        /// For C++
        Attribute = 4,
        /// For Lean
        Axiom = 5,
        Boolean = 6,
        Class = 7,
        Constant = 8,
        Constructor = 9,
        /// For Solidity
        Contract = 62,
        /// For Haskell
        DataFamily = 10,
        /// For C# and F#
        Delegate = 73,
        Enum = 11,
        EnumMember = 12,
        Error = 63,
        Event = 13,
        /// For Alloy
        Fact = 14,
        Field = 15,
        File = 16,
        Function = 17,
        /// For 'get' in Swift, 'attr_reader' in Ruby
        Getter = 18,
        /// For Raku
        Grammar = 19,
        /// For Purescript and Lean
        Instance = 20,
        Interface = 21,
        Key = 22,
        /// For Racket
        Lang = 23,
        /// For Lean
        Lemma = 24,
        /// For solidity
        Library = 64,
        Macro = 25,
        Method = 26,
        /// For Ruby
        MethodAlias = 74,
        /// Analogous to 'ThisParameter' and 'SelfParameter', but for languages
        /// like Go where the receiver doesn't have a conventional name.
        MethodReceiver = 27,
        /// Analogous to 'AbstractMethod', for Go.
        MethodSpecification = 67,
        /// For Protobuf
        Message = 28,
        /// For Solidity
        Modifier = 65,
        Module = 29,
        Namespace = 30,
        Null = 31,
        Number = 32,
        Object = 33,
        Operator = 34,
        Package = 35,
        PackageObject = 36,
        Parameter = 37,
        ParameterLabel = 38,
        /// For Haskell's PatternSynonyms
        Pattern = 39,
        /// For Alloy
        Predicate = 40,
        Property = 41,
        /// Analogous to 'Trait' and 'TypeClass', for Swift and Objective-C
        Protocol = 42,
        /// Analogous to 'AbstractMethod', for Swift and Objective-C.
        ProtocolMethod = 68,
        /// Analogous to 'AbstractMethod', for C++.
        PureVirtualMethod = 69,
        /// For Haskell
        Quasiquoter = 43,
        /// 'self' in Python, Rust, Swift etc.
        SelfParameter = 44,
        /// For 'set' in Swift, 'attr_writer' in Ruby
        Setter = 45,
        /// For Alloy, analogous to 'Struct'.
        Signature = 46,
        /// For Ruby
        SingletonClass = 75,
        /// Analogous to 'StaticMethod', for Ruby.
        SingletonMethod = 76,
        /// Analogous to 'StaticField', for C++
        StaticDataMember = 77,
        /// For C#
        StaticEvent = 78,
        /// For C#
        StaticField = 79,
        /// For Java, C#, C++ etc.
        StaticMethod = 80,
        /// For C#, TypeScript etc.
        StaticProperty = 81,
        /// For C, C++
        StaticVariable = 82,
        String = 48,
        Struct = 49,
        /// For Swift
        Subscript = 47,
        /// For Lean
        Tactic = 50,
        /// For Lean
        Theorem = 51,
        /// Method receiver for languages
        /// 'this' in JavaScript, C++, Java etc.
        ThisParameter = 52,
        /// Analogous to 'Protocol' and 'TypeClass', for Rust, Scala etc.
        Trait = 53,
        /// Analogous to 'AbstractMethod', for Rust, Scala etc.
        TraitMethod = 70,
        /// Data type definition for languages like OCaml which use `type`
        /// rather than separate keywords like `struct` and `enum`.
        Type = 54,
        TypeAlias = 55,
        /// Analogous to 'Trait' and 'Protocol', for Haskell, Purescript etc.
        TypeClass = 56,
        /// Analogous to 'AbstractMethod', for Haskell, Purescript etc.
        TypeClassMethod = 71,
        /// For Haskell
        TypeFamily = 57,
        TypeParameter = 58,
        /// For C, C++, Capn Proto
        Union = 59,
        Value = 60,
        /// Next = 83;
        /// Feel free to open a PR proposing new language-specific kinds.
        Variable = 61,
    }
    impl Kind {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Kind::UnspecifiedKind => "UnspecifiedKind",
                Kind::AbstractMethod => "AbstractMethod",
                Kind::Accessor => "Accessor",
                Kind::Array => "Array",
                Kind::Assertion => "Assertion",
                Kind::AssociatedType => "AssociatedType",
                Kind::Attribute => "Attribute",
                Kind::Axiom => "Axiom",
                Kind::Boolean => "Boolean",
                Kind::Class => "Class",
                Kind::Constant => "Constant",
                Kind::Constructor => "Constructor",
                Kind::Contract => "Contract",
                Kind::DataFamily => "DataFamily",
                Kind::Delegate => "Delegate",
                Kind::Enum => "Enum",
                Kind::EnumMember => "EnumMember",
                Kind::Error => "Error",
                Kind::Event => "Event",
                Kind::Fact => "Fact",
                Kind::Field => "Field",
                Kind::File => "File",
                Kind::Function => "Function",
                Kind::Getter => "Getter",
                Kind::Grammar => "Grammar",
                Kind::Instance => "Instance",
                Kind::Interface => "Interface",
                Kind::Key => "Key",
                Kind::Lang => "Lang",
                Kind::Lemma => "Lemma",
                Kind::Library => "Library",
                Kind::Macro => "Macro",
                Kind::Method => "Method",
                Kind::MethodAlias => "MethodAlias",
                Kind::MethodReceiver => "MethodReceiver",
                Kind::MethodSpecification => "MethodSpecification",
                Kind::Message => "Message",
                Kind::Modifier => "Modifier",
                Kind::Module => "Module",
                Kind::Namespace => "Namespace",
                Kind::Null => "Null",
                Kind::Number => "Number",
                Kind::Object => "Object",
                Kind::Operator => "Operator",
                Kind::Package => "Package",
                Kind::PackageObject => "PackageObject",
                Kind::Parameter => "Parameter",
                Kind::ParameterLabel => "ParameterLabel",
                Kind::Pattern => "Pattern",
                Kind::Predicate => "Predicate",
                Kind::Property => "Property",
                Kind::Protocol => "Protocol",
                Kind::ProtocolMethod => "ProtocolMethod",
                Kind::PureVirtualMethod => "PureVirtualMethod",
                Kind::Quasiquoter => "Quasiquoter",
                Kind::SelfParameter => "SelfParameter",
                Kind::Setter => "Setter",
                Kind::Signature => "Signature",
                Kind::SingletonClass => "SingletonClass",
                Kind::SingletonMethod => "SingletonMethod",
                Kind::StaticDataMember => "StaticDataMember",
                Kind::StaticEvent => "StaticEvent",
                Kind::StaticField => "StaticField",
                Kind::StaticMethod => "StaticMethod",
                Kind::StaticProperty => "StaticProperty",
                Kind::StaticVariable => "StaticVariable",
                Kind::String => "String",
                Kind::Struct => "Struct",
                Kind::Subscript => "Subscript",
                Kind::Tactic => "Tactic",
                Kind::Theorem => "Theorem",
                Kind::ThisParameter => "ThisParameter",
                Kind::Trait => "Trait",
                Kind::TraitMethod => "TraitMethod",
                Kind::Type => "Type",
                Kind::TypeAlias => "TypeAlias",
                Kind::TypeClass => "TypeClass",
                Kind::TypeClassMethod => "TypeClassMethod",
                Kind::TypeFamily => "TypeFamily",
                Kind::TypeParameter => "TypeParameter",
                Kind::Union => "Union",
                Kind::Value => "Value",
                Kind::Variable => "Variable",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UnspecifiedKind" => Some(Self::UnspecifiedKind),
                "AbstractMethod" => Some(Self::AbstractMethod),
                "Accessor" => Some(Self::Accessor),
                "Array" => Some(Self::Array),
                "Assertion" => Some(Self::Assertion),
                "AssociatedType" => Some(Self::AssociatedType),
                "Attribute" => Some(Self::Attribute),
                "Axiom" => Some(Self::Axiom),
                "Boolean" => Some(Self::Boolean),
                "Class" => Some(Self::Class),
                "Constant" => Some(Self::Constant),
                "Constructor" => Some(Self::Constructor),
                "Contract" => Some(Self::Contract),
                "DataFamily" => Some(Self::DataFamily),
                "Delegate" => Some(Self::Delegate),
                "Enum" => Some(Self::Enum),
                "EnumMember" => Some(Self::EnumMember),
                "Error" => Some(Self::Error),
                "Event" => Some(Self::Event),
                "Fact" => Some(Self::Fact),
                "Field" => Some(Self::Field),
                "File" => Some(Self::File),
                "Function" => Some(Self::Function),
                "Getter" => Some(Self::Getter),
                "Grammar" => Some(Self::Grammar),
                "Instance" => Some(Self::Instance),
                "Interface" => Some(Self::Interface),
                "Key" => Some(Self::Key),
                "Lang" => Some(Self::Lang),
                "Lemma" => Some(Self::Lemma),
                "Library" => Some(Self::Library),
                "Macro" => Some(Self::Macro),
                "Method" => Some(Self::Method),
                "MethodAlias" => Some(Self::MethodAlias),
                "MethodReceiver" => Some(Self::MethodReceiver),
                "MethodSpecification" => Some(Self::MethodSpecification),
                "Message" => Some(Self::Message),
                "Modifier" => Some(Self::Modifier),
                "Module" => Some(Self::Module),
                "Namespace" => Some(Self::Namespace),
                "Null" => Some(Self::Null),
                "Number" => Some(Self::Number),
                "Object" => Some(Self::Object),
                "Operator" => Some(Self::Operator),
                "Package" => Some(Self::Package),
                "PackageObject" => Some(Self::PackageObject),
                "Parameter" => Some(Self::Parameter),
                "ParameterLabel" => Some(Self::ParameterLabel),
                "Pattern" => Some(Self::Pattern),
                "Predicate" => Some(Self::Predicate),
                "Property" => Some(Self::Property),
                "Protocol" => Some(Self::Protocol),
                "ProtocolMethod" => Some(Self::ProtocolMethod),
                "PureVirtualMethod" => Some(Self::PureVirtualMethod),
                "Quasiquoter" => Some(Self::Quasiquoter),
                "SelfParameter" => Some(Self::SelfParameter),
                "Setter" => Some(Self::Setter),
                "Signature" => Some(Self::Signature),
                "SingletonClass" => Some(Self::SingletonClass),
                "SingletonMethod" => Some(Self::SingletonMethod),
                "StaticDataMember" => Some(Self::StaticDataMember),
                "StaticEvent" => Some(Self::StaticEvent),
                "StaticField" => Some(Self::StaticField),
                "StaticMethod" => Some(Self::StaticMethod),
                "StaticProperty" => Some(Self::StaticProperty),
                "StaticVariable" => Some(Self::StaticVariable),
                "String" => Some(Self::String),
                "Struct" => Some(Self::Struct),
                "Subscript" => Some(Self::Subscript),
                "Tactic" => Some(Self::Tactic),
                "Theorem" => Some(Self::Theorem),
                "ThisParameter" => Some(Self::ThisParameter),
                "Trait" => Some(Self::Trait),
                "TraitMethod" => Some(Self::TraitMethod),
                "Type" => Some(Self::Type),
                "TypeAlias" => Some(Self::TypeAlias),
                "TypeClass" => Some(Self::TypeClass),
                "TypeClassMethod" => Some(Self::TypeClassMethod),
                "TypeFamily" => Some(Self::TypeFamily),
                "TypeParameter" => Some(Self::TypeParameter),
                "Union" => Some(Self::Union),
                "Value" => Some(Self::Value),
                "Variable" => Some(Self::Variable),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Relationship {
    #[prost(string, tag = "1")]
    pub symbol: ::prost::alloc::string::String,
    /// When resolving "Find references", this field documents what other symbols
    /// should be included together with this symbol. For example, consider the
    /// following TypeScript code that defines two symbols `Animal#sound()` and
    /// `Dog#sound()`:
    /// ```ts
    /// interface Animal {
    ///            ^^^^^^ definition Animal#
    ///    sound(): string
    ///    ^^^^^ definition Animal#sound()
    /// }
    /// class Dog implements Animal {
    ///        ^^^ definition Dog#, relationships = \[{symbol: "Animal#", is_implementation: true}\]
    ///    public sound(): string { return "woof" }
    ///           ^^^^^ definition Dog#sound(), references_symbols = Animal#sound(), relationships = \[{symbol: "Animal#sound()", is_implementation:true, is_reference: true}\]
    /// }
    /// const animal: Animal = new Dog()
    ///                ^^^^^^ reference Animal#
    /// console.log(animal.sound())
    ///                     ^^^^^ reference Animal#sound()
    /// ```
    /// Doing "Find references" on the symbol `Animal#sound()` should return
    /// references to the `Dog#sound()` method as well. Vice-versa, doing "Find
    /// references" on the `Dog#sound()` method should include references to the
    /// `Animal#sound()` method as well.
    #[prost(bool, tag = "2")]
    pub is_reference: bool,
    /// Similar to `is_reference` but for "Find implementations".
    /// It's common for `is_implementation` and `is_reference` to both be true but
    /// it's not always the case.
    /// In the TypeScript example above, observe that `Dog#` has an
    /// `is_implementation` relationship with `"Animal#"` but not `is_reference`.
    /// This is because "Find references" on the "Animal#" symbol should not return
    /// "Dog#". We only want "Dog#" to return as a result for "Find
    /// implementations" on the "Animal#" symbol.
    #[prost(bool, tag = "3")]
    pub is_implementation: bool,
    /// Similar to `references_symbols` but for "Go to type definition".
    #[prost(bool, tag = "4")]
    pub is_type_definition: bool,
    /// Allows overriding the behavior of "Go to definition" and "Find references"
    /// for symbols which do not have a definition of their own or could
    /// potentially have multiple definitions.
    ///
    /// For example, in a language with single inheritance and no field overriding,
    /// inherited fields can reuse the same symbol as the ancestor which declares
    /// the field. In such a situation, is_definition is not needed.
    ///
    /// On the other hand, in languages with single inheritance and some form
    /// of mixins, you can use is_definition to relate the symbol to the
    /// matching symbol in ancestor classes, and is_reference to relate the
    /// symbol to the matching symbol in mixins.
    ///
    /// NOTE: At the moment, due to limitations of the SCIP to LSIF conversion,
    /// only global symbols in an index are allowed to use is_definition.
    /// The relationship may not get recorded if either symbol is local.
    ///
    /// Update registerInverseRelationships on adding a new field here.
    #[prost(bool, tag = "5")]
    pub is_definition: bool,
}
/// Occurrence associates a source position with a symbol and/or highlighting
/// information.
///
/// If possible, indexers should try to bundle logically related information
/// across occurrences into a single occurrence to reduce payload sizes.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Occurrence {
    /// Half-open [start, end) range of this occurrence. Must be exactly three or four
    /// elements:
    ///
    /// - Four elements: `\[startLine, startCharacter, endLine, endCharacter\]`
    /// - Three elements: `\[startLine, startCharacter, endCharacter\]`. The end line
    ///    is inferred to have the same value as the start line.
    ///
    /// It is allowed for the range to be empty (i.e. start==end).
    ///
    /// Line numbers and characters are always 0-based. Make sure to increment the
    /// line/character values before displaying them in an editor-like UI because
    /// editors conventionally use 1-based numbers.
    ///
    /// The 'character' value is interpreted based on the PositionEncoding for
    /// the Document.
    ///
    /// Historical note: the original draft of this schema had a `Range` message
    /// type with `start` and `end` fields of type `Position`, mirroring LSP.
    /// Benchmarks revealed that this encoding was inefficient and that we could
    /// reduce the total payload size of an index by 50% by using `repeated int32`
    /// instead. The `repeated int32` encoding is admittedly more embarrassing to
    /// work with in some programming languages but we hope the performance
    /// improvements make up for it.
    #[prost(int32, repeated, tag = "1")]
    pub range: ::prost::alloc::vec::Vec<i32>,
    /// (optional) The symbol that appears at this position. See
    /// `SymbolInformation.symbol` for how to format symbols as strings.
    #[prost(string, tag = "2")]
    pub symbol: ::prost::alloc::string::String,
    /// (optional) Bitset containing `SymbolRole`s in this occurrence.
    /// See `SymbolRole`'s documentation for how to read and write this field.
    #[prost(int32, tag = "3")]
    pub symbol_roles: i32,
    /// (optional) CommonMark-formatted documentation for this specific range. If
    /// empty, the `Symbol.documentation` field is used instead. One example
    /// where this field might be useful is when the symbol represents a generic
    /// function (with abstract type parameters such as `List<T>`) and at this
    /// occurrence we know the exact values (such as `List<String>`).
    ///
    /// This field can also be used for dynamically or gradually typed languages,
    /// which commonly allow for type-changing assignment.
    #[prost(string, repeated, tag = "4")]
    pub override_documentation: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// (optional) What syntax highlighting class should be used for this range?
    #[prost(enumeration = "SyntaxKind", tag = "5")]
    pub syntax_kind: i32,
    /// (optional) Diagnostics that have been reported for this specific range.
    #[prost(message, repeated, tag = "6")]
    pub diagnostics: ::prost::alloc::vec::Vec<Diagnostic>,
    /// (optional) Using the same encoding as the sibling `range` field, half-open
    /// source range of the nearest non-trivial enclosing AST node. This range must
    /// enclose the `range` field. Example applications that make use of the
    /// enclosing_range field:
    ///
    /// - Call hierarchies: to determine what symbols are references from the body
    ///    of a function
    /// - Symbol outline: to display breadcrumbs from the cursor position to the
    ///    root of the file
    /// - Expand selection: to select the nearest enclosing AST node.
    /// - Highlight range: to indicate the AST expression that is associated with a
    ///    hover popover
    ///
    /// For definition occurrences, the enclosing range should indicate the
    /// start/end bounds of the entire definition AST node, including
    /// documentation.
    /// ```
    /// const n = 3
    ///        ^ range
    /// ^^^^^^^^^^^ enclosing_range
    ///
    /// /** Parses the string into something */
    /// ^ enclosing_range start --------------------------------------|
    /// function parse(input string): string {                        |
    ///           ^^^^^ range                                          |
    ///      return input.slice(n)                                     |
    /// }                                                             |
    /// ^ enclosing_range end <---------------------------------------|
    /// ```
    ///
    /// Any attributes/decorators/attached macros should also be part of the
    /// enclosing range.
    ///
    /// ```python
    /// @cache
    /// ^ enclosing_range start---------------------|
    /// def factorial(n):                           |
    ///      return n * factorial(n-1) if n else 1   |
    /// < enclosing_range end-----------------------|
    ///
    /// ```
    ///
    /// For reference occurrences, the enclosing range should indicate the start/end
    /// bounds of the parent expression.
    /// ```
    /// const a = a.b
    ///              ^ range
    ///            ^^^ enclosing_range
    /// const b = a.b(41).f(42).g(43)
    ///                    ^ range
    ///            ^^^^^^^^^^^^^ enclosing_range
    /// ```
    #[prost(int32, repeated, tag = "7")]
    pub enclosing_range: ::prost::alloc::vec::Vec<i32>,
}
/// Represents a diagnostic, such as a compiler error or warning, which should be
/// reported for a document.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Diagnostic {
    /// Should this diagnostic be reported as an error, warning, info, or hint?
    #[prost(enumeration = "Severity", tag = "1")]
    pub severity: i32,
    /// (optional) Code of this diagnostic, which might appear in the user interface.
    #[prost(string, tag = "2")]
    pub code: ::prost::alloc::string::String,
    /// Message of this diagnostic.
    #[prost(string, tag = "3")]
    pub message: ::prost::alloc::string::String,
    /// (optional) Human-readable string describing the source of this diagnostic, e.g.
    /// 'typescript' or 'super lint'.
    #[prost(string, tag = "4")]
    pub source: ::prost::alloc::string::String,
    #[prost(enumeration = "DiagnosticTag", repeated, tag = "5")]
    pub tags: ::prost::alloc::vec::Vec<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ProtocolVersion {
    UnspecifiedProtocolVersion = 0,
}
impl ProtocolVersion {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ProtocolVersion::UnspecifiedProtocolVersion => "UnspecifiedProtocolVersion",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UnspecifiedProtocolVersion" => Some(Self::UnspecifiedProtocolVersion),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TextEncoding {
    UnspecifiedTextEncoding = 0,
    Utf8 = 1,
    Utf16 = 2,
}
impl TextEncoding {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            TextEncoding::UnspecifiedTextEncoding => "UnspecifiedTextEncoding",
            TextEncoding::Utf8 => "UTF8",
            TextEncoding::Utf16 => "UTF16",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UnspecifiedTextEncoding" => Some(Self::UnspecifiedTextEncoding),
            "UTF8" => Some(Self::Utf8),
            "UTF16" => Some(Self::Utf16),
            _ => None,
        }
    }
}
/// Encoding used to interpret the 'character' value in source ranges.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PositionEncoding {
    /// Default value. This value should not be used by new SCIP indexers
    /// so that a consumer can process the SCIP index without ambiguity.
    UnspecifiedPositionEncoding = 0,
    /// The 'character' value is interpreted as an offset in terms
    /// of UTF-8 code units (i.e. bytes).
    ///
    /// Example: For the string "🚀 Woo" in UTF-8, the bytes are
    /// \[240, 159, 154, 128, 32, 87, 111, 111\], so the offset for 'W'
    /// would be 5.
    Utf8CodeUnitOffsetFromLineStart = 1,
    /// The 'character' value is interpreted as an offset in terms
    /// of UTF-16 code units (each is 2 bytes).
    ///
    /// Example: For the string "🚀 Woo", the UTF-16 code units are
    /// \['\ud83d', '\ude80', ' ', 'W', 'o', 'o'\], so the offset for 'W'
    /// would be 3.
    Utf16CodeUnitOffsetFromLineStart = 2,
    /// The 'character' value is interpreted as an offset in terms
    /// of UTF-32 code units (each is 4 bytes).
    ///
    /// Example: For the string "🚀 Woo", the UTF-32 code units are
    /// \['🚀', ' ', 'W', 'o', 'o'\], so the offset for 'W' would be 2.
    Utf32CodeUnitOffsetFromLineStart = 3,
}
impl PositionEncoding {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            PositionEncoding::UnspecifiedPositionEncoding => {
                "UnspecifiedPositionEncoding"
            }
            PositionEncoding::Utf8CodeUnitOffsetFromLineStart => {
                "UTF8CodeUnitOffsetFromLineStart"
            }
            PositionEncoding::Utf16CodeUnitOffsetFromLineStart => {
                "UTF16CodeUnitOffsetFromLineStart"
            }
            PositionEncoding::Utf32CodeUnitOffsetFromLineStart => {
                "UTF32CodeUnitOffsetFromLineStart"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UnspecifiedPositionEncoding" => Some(Self::UnspecifiedPositionEncoding),
            "UTF8CodeUnitOffsetFromLineStart" => {
                Some(Self::Utf8CodeUnitOffsetFromLineStart)
            }
            "UTF16CodeUnitOffsetFromLineStart" => {
                Some(Self::Utf16CodeUnitOffsetFromLineStart)
            }
            "UTF32CodeUnitOffsetFromLineStart" => {
                Some(Self::Utf32CodeUnitOffsetFromLineStart)
            }
            _ => None,
        }
    }
}
/// SymbolRole declares what "role" a symbol has in an occurrence. A role is
/// encoded as a bitset where each bit represents a different role. For example,
/// to determine if the `Import` role is set, test whether the second bit of the
/// enum value is defined. In pseudocode, this can be implemented with the
/// logic: `const isImportRole = (role.value & SymbolRole.Import.value) > 0`.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SymbolRole {
    /// This case is not meant to be used; it only exists to avoid an error
    /// from the Protobuf code generator.
    UnspecifiedSymbolRole = 0,
    /// Is the symbol defined here? If not, then this is a symbol reference.
    Definition = 1,
    /// Is the symbol imported here?
    Import = 2,
    /// Is the symbol written here?
    WriteAccess = 4,
    /// Is the symbol read here?
    ReadAccess = 8,
    /// Is the symbol in generated code?
    Generated = 16,
    /// Is the symbol in test code?
    Test = 32,
    /// Is this a signature for a symbol that is defined elsewhere?
    ///
    /// Applies to forward declarations for languages like C, C++
    /// and Objective-C, as well as `val` declarations in interface
    /// files in languages like SML and OCaml.
    ForwardDefinition = 64,
}
impl SymbolRole {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            SymbolRole::UnspecifiedSymbolRole => "UnspecifiedSymbolRole",
            SymbolRole::Definition => "Definition",
            SymbolRole::Import => "Import",
            SymbolRole::WriteAccess => "WriteAccess",
            SymbolRole::ReadAccess => "ReadAccess",
            SymbolRole::Generated => "Generated",
            SymbolRole::Test => "Test",
            SymbolRole::ForwardDefinition => "ForwardDefinition",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UnspecifiedSymbolRole" => Some(Self::UnspecifiedSymbolRole),
            "Definition" => Some(Self::Definition),
            "Import" => Some(Self::Import),
            "WriteAccess" => Some(Self::WriteAccess),
            "ReadAccess" => Some(Self::ReadAccess),
            "Generated" => Some(Self::Generated),
            "Test" => Some(Self::Test),
            "ForwardDefinition" => Some(Self::ForwardDefinition),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SyntaxKind {
    UnspecifiedSyntaxKind = 0,
    /// Comment, including comment markers and text
    Comment = 1,
    /// `;` `.` `,`
    PunctuationDelimiter = 2,
    /// (), {}, \[\] when used syntactically
    PunctuationBracket = 3,
    /// `if`, `else`, `return`, `class`, etc.
    Keyword = 4,
    /// `+`, `*`, etc.
    IdentifierOperator = 5,
    /// non-specific catch-all for any identifier not better described elsewhere
    Identifier = 6,
    /// Identifiers builtin to the language: `min`, `print` in Python.
    IdentifierBuiltin = 7,
    /// Identifiers representing `null`-like values: `None` in Python, `nil` in Go.
    IdentifierNull = 8,
    /// `xyz` in `const xyz = "hello"`
    IdentifierConstant = 9,
    /// `var X = "hello"` in Go
    IdentifierMutableGlobal = 10,
    /// Parameter definition and references
    IdentifierParameter = 11,
    /// Identifiers for variable definitions and references within a local scope
    IdentifierLocal = 12,
    /// Identifiers that shadow other identifiers in an outer scope
    IdentifierShadowed = 13,
    /// Identifier representing a unit of code abstraction and/or namespacing.
    ///
    /// NOTE: This corresponds to a package in Go and JVM languages,
    /// and a module in languages like Python and JavaScript.
    IdentifierNamespace = 14,
    /// Function references, including calls
    IdentifierFunction = 15,
    /// Function definition only
    IdentifierFunctionDefinition = 16,
    /// Macro references, including invocations
    IdentifierMacro = 17,
    /// Macro definition only
    IdentifierMacroDefinition = 18,
    /// non-builtin types
    IdentifierType = 19,
    /// builtin types only, such as `str` for Python or `int` in Go
    IdentifierBuiltinType = 20,
    /// Python decorators, c-like __attribute__
    IdentifierAttribute = 21,
    /// `\b`
    RegexEscape = 22,
    /// `*`, `+`
    RegexRepeated = 23,
    /// `.`
    RegexWildcard = 24,
    /// `(`, `)`, `\[`, `\]`
    RegexDelimiter = 25,
    /// `|`, `-`
    RegexJoin = 26,
    /// Literal strings: "Hello, world!"
    StringLiteral = 27,
    /// non-regex escapes: "\t", "\n"
    StringLiteralEscape = 28,
    /// datetimes within strings, special words within a string, `{}` in format strings
    StringLiteralSpecial = 29,
    /// "key" in { "key": "value" }, useful for example in JSON
    StringLiteralKey = 30,
    /// 'c' or similar, in languages that differentiate strings and characters
    CharacterLiteral = 31,
    /// Literal numbers, both floats and integers
    NumericLiteral = 32,
    /// `true`, `false`
    BooleanLiteral = 33,
    /// Used for XML-like tags
    Tag = 34,
    /// Attribute name in XML-like tags
    TagAttribute = 35,
    /// Delimiters for XML-like tags
    TagDelimiter = 36,
}
impl SyntaxKind {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            SyntaxKind::UnspecifiedSyntaxKind => "UnspecifiedSyntaxKind",
            SyntaxKind::Comment => "Comment",
            SyntaxKind::PunctuationDelimiter => "PunctuationDelimiter",
            SyntaxKind::PunctuationBracket => "PunctuationBracket",
            SyntaxKind::Keyword => "Keyword",
            SyntaxKind::IdentifierOperator => "IdentifierOperator",
            SyntaxKind::Identifier => "Identifier",
            SyntaxKind::IdentifierBuiltin => "IdentifierBuiltin",
            SyntaxKind::IdentifierNull => "IdentifierNull",
            SyntaxKind::IdentifierConstant => "IdentifierConstant",
            SyntaxKind::IdentifierMutableGlobal => "IdentifierMutableGlobal",
            SyntaxKind::IdentifierParameter => "IdentifierParameter",
            SyntaxKind::IdentifierLocal => "IdentifierLocal",
            SyntaxKind::IdentifierShadowed => "IdentifierShadowed",
            SyntaxKind::IdentifierNamespace => "IdentifierNamespace",
            SyntaxKind::IdentifierFunction => "IdentifierFunction",
            SyntaxKind::IdentifierFunctionDefinition => "IdentifierFunctionDefinition",
            SyntaxKind::IdentifierMacro => "IdentifierMacro",
            SyntaxKind::IdentifierMacroDefinition => "IdentifierMacroDefinition",
            SyntaxKind::IdentifierType => "IdentifierType",
            SyntaxKind::IdentifierBuiltinType => "IdentifierBuiltinType",
            SyntaxKind::IdentifierAttribute => "IdentifierAttribute",
            SyntaxKind::RegexEscape => "RegexEscape",
            SyntaxKind::RegexRepeated => "RegexRepeated",
            SyntaxKind::RegexWildcard => "RegexWildcard",
            SyntaxKind::RegexDelimiter => "RegexDelimiter",
            SyntaxKind::RegexJoin => "RegexJoin",
            SyntaxKind::StringLiteral => "StringLiteral",
            SyntaxKind::StringLiteralEscape => "StringLiteralEscape",
            SyntaxKind::StringLiteralSpecial => "StringLiteralSpecial",
            SyntaxKind::StringLiteralKey => "StringLiteralKey",
            SyntaxKind::CharacterLiteral => "CharacterLiteral",
            SyntaxKind::NumericLiteral => "NumericLiteral",
            SyntaxKind::BooleanLiteral => "BooleanLiteral",
            SyntaxKind::Tag => "Tag",
            SyntaxKind::TagAttribute => "TagAttribute",
            SyntaxKind::TagDelimiter => "TagDelimiter",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UnspecifiedSyntaxKind" => Some(Self::UnspecifiedSyntaxKind),
            "Comment" => Some(Self::Comment),
            "PunctuationDelimiter" => Some(Self::PunctuationDelimiter),
            "PunctuationBracket" => Some(Self::PunctuationBracket),
            "Keyword" => Some(Self::Keyword),
            "IdentifierOperator" => Some(Self::IdentifierOperator),
            "Identifier" => Some(Self::Identifier),
            "IdentifierBuiltin" => Some(Self::IdentifierBuiltin),
            "IdentifierNull" => Some(Self::IdentifierNull),
            "IdentifierConstant" => Some(Self::IdentifierConstant),
            "IdentifierMutableGlobal" => Some(Self::IdentifierMutableGlobal),
            "IdentifierParameter" => Some(Self::IdentifierParameter),
            "IdentifierLocal" => Some(Self::IdentifierLocal),
            "IdentifierShadowed" => Some(Self::IdentifierShadowed),
            "IdentifierNamespace" => Some(Self::IdentifierNamespace),
            "IdentifierFunction" => Some(Self::IdentifierFunction),
            "IdentifierFunctionDefinition" => Some(Self::IdentifierFunctionDefinition),
            "IdentifierMacro" => Some(Self::IdentifierMacro),
            "IdentifierMacroDefinition" => Some(Self::IdentifierMacroDefinition),
            "IdentifierType" => Some(Self::IdentifierType),
            "IdentifierBuiltinType" => Some(Self::IdentifierBuiltinType),
            "IdentifierAttribute" => Some(Self::IdentifierAttribute),
            "RegexEscape" => Some(Self::RegexEscape),
            "RegexRepeated" => Some(Self::RegexRepeated),
            "RegexWildcard" => Some(Self::RegexWildcard),
            "RegexDelimiter" => Some(Self::RegexDelimiter),
            "RegexJoin" => Some(Self::RegexJoin),
            "StringLiteral" => Some(Self::StringLiteral),
            "StringLiteralEscape" => Some(Self::StringLiteralEscape),
            "StringLiteralSpecial" => Some(Self::StringLiteralSpecial),
            "StringLiteralKey" => Some(Self::StringLiteralKey),
            "CharacterLiteral" => Some(Self::CharacterLiteral),
            "NumericLiteral" => Some(Self::NumericLiteral),
            "BooleanLiteral" => Some(Self::BooleanLiteral),
            "Tag" => Some(Self::Tag),
            "TagAttribute" => Some(Self::TagAttribute),
            "TagDelimiter" => Some(Self::TagDelimiter),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Severity {
    UnspecifiedSeverity = 0,
    Error = 1,
    Warning = 2,
    Information = 3,
    Hint = 4,
}
impl Severity {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Severity::UnspecifiedSeverity => "UnspecifiedSeverity",
            Severity::Error => "Error",
            Severity::Warning => "Warning",
            Severity::Information => "Information",
            Severity::Hint => "Hint",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UnspecifiedSeverity" => Some(Self::UnspecifiedSeverity),
            "Error" => Some(Self::Error),
            "Warning" => Some(Self::Warning),
            "Information" => Some(Self::Information),
            "Hint" => Some(Self::Hint),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DiagnosticTag {
    UnspecifiedDiagnosticTag = 0,
    Unnecessary = 1,
    Deprecated = 2,
}
impl DiagnosticTag {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            DiagnosticTag::UnspecifiedDiagnosticTag => "UnspecifiedDiagnosticTag",
            DiagnosticTag::Unnecessary => "Unnecessary",
            DiagnosticTag::Deprecated => "Deprecated",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UnspecifiedDiagnosticTag" => Some(Self::UnspecifiedDiagnosticTag),
            "Unnecessary" => Some(Self::Unnecessary),
            "Deprecated" => Some(Self::Deprecated),
            _ => None,
        }
    }
}
/// Language standardises names of common programming languages that can be used
/// for the `Document.language` field. The primary purpose of this enum is to
/// prevent a situation where we have a single programming language ends up with
/// multiple string representations. For example, the C++ language uses the name
/// "CPP" in this enum and other names such as "cpp" are incompatible.
/// Feel free to send a pull-request to add missing programming languages.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Language {
    UnspecifiedLanguage = 0,
    Abap = 60,
    Apex = 96,
    Apl = 49,
    Ada = 39,
    Agda = 45,
    AsciiDoc = 86,
    Assembly = 58,
    Awk = 66,
    Bat = 68,
    BibTeX = 81,
    C = 34,
    Cobol = 59,
    /// C++ (the name "CPP" was chosen for consistency with LSP)
    Cpp = 35,
    Css = 26,
    CSharp = 1,
    Clojure = 8,
    Coffeescript = 21,
    CommonLisp = 9,
    Coq = 47,
    Cuda = 97,
    Dart = 3,
    Delphi = 57,
    Diff = 88,
    Dockerfile = 80,
    Dyalog = 50,
    Elixir = 17,
    Erlang = 18,
    FSharp = 42,
    Fish = 65,
    Flow = 24,
    Fortran = 56,
    GitCommit = 91,
    GitConfig = 89,
    GitRebase = 92,
    Go = 33,
    GraphQl = 98,
    Groovy = 7,
    Html = 30,
    Hack = 20,
    Handlebars = 90,
    Haskell = 44,
    Idris = 46,
    Ini = 72,
    J = 51,
    Json = 75,
    Java = 6,
    JavaScript = 22,
    JavaScriptReact = 93,
    Jsonnet = 76,
    Julia = 55,
    Justfile = 109,
    Kotlin = 4,
    LaTeX = 83,
    Lean = 48,
    Less = 27,
    Lua = 12,
    Luau = 108,
    Makefile = 79,
    Markdown = 84,
    Matlab = 52,
    /// <https://nickel-lang.org/>
    Nickel = 110,
    Nix = 77,
    OCaml = 41,
    ObjectiveC = 36,
    ObjectiveCpp = 37,
    Pascal = 99,
    Php = 19,
    Plsql = 70,
    Perl = 13,
    PowerShell = 67,
    Prolog = 71,
    Protobuf = 100,
    Python = 15,
    R = 54,
    Racket = 11,
    Raku = 14,
    Razor = 62,
    /// Internal language for testing SCIP
    Repro = 102,
    ReSt = 85,
    Ruby = 16,
    Rust = 40,
    Sas = 61,
    Scss = 29,
    Sml = 43,
    Sql = 69,
    Sass = 28,
    Scala = 5,
    Scheme = 10,
    /// Bash
    ShellScript = 64,
    Skylark = 78,
    Slang = 107,
    Solidity = 95,
    Svelte = 106,
    Swift = 2,
    Tcl = 101,
    Toml = 73,
    TeX = 82,
    Thrift = 103,
    TypeScript = 23,
    TypeScriptReact = 94,
    Verilog = 104,
    Vhdl = 105,
    VisualBasic = 63,
    Vue = 25,
    Wolfram = 53,
    Xml = 31,
    Xsl = 32,
    Yaml = 74,
    /// NextLanguage = 111;
    /// Steps add a new language:
    /// 1. Copy-paste the "NextLanguage = N" line above
    /// 2. Increment "NextLanguage = N" to "NextLanguage = N+1"
    /// 3. Replace "NextLanguage = N" with the name of the new language.
    /// 4. Move the new language to the correct line above using alphabetical order
    /// 5. (optional) Add a brief comment behind the language if the name is not self-explanatory
    Zig = 38,
}
impl Language {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Language::UnspecifiedLanguage => "UnspecifiedLanguage",
            Language::Abap => "ABAP",
            Language::Apex => "Apex",
            Language::Apl => "APL",
            Language::Ada => "Ada",
            Language::Agda => "Agda",
            Language::AsciiDoc => "AsciiDoc",
            Language::Assembly => "Assembly",
            Language::Awk => "Awk",
            Language::Bat => "Bat",
            Language::BibTeX => "BibTeX",
            Language::C => "C",
            Language::Cobol => "COBOL",
            Language::Cpp => "CPP",
            Language::Css => "CSS",
            Language::CSharp => "CSharp",
            Language::Clojure => "Clojure",
            Language::Coffeescript => "Coffeescript",
            Language::CommonLisp => "CommonLisp",
            Language::Coq => "Coq",
            Language::Cuda => "CUDA",
            Language::Dart => "Dart",
            Language::Delphi => "Delphi",
            Language::Diff => "Diff",
            Language::Dockerfile => "Dockerfile",
            Language::Dyalog => "Dyalog",
            Language::Elixir => "Elixir",
            Language::Erlang => "Erlang",
            Language::FSharp => "FSharp",
            Language::Fish => "Fish",
            Language::Flow => "Flow",
            Language::Fortran => "Fortran",
            Language::GitCommit => "Git_Commit",
            Language::GitConfig => "Git_Config",
            Language::GitRebase => "Git_Rebase",
            Language::Go => "Go",
            Language::GraphQl => "GraphQL",
            Language::Groovy => "Groovy",
            Language::Html => "HTML",
            Language::Hack => "Hack",
            Language::Handlebars => "Handlebars",
            Language::Haskell => "Haskell",
            Language::Idris => "Idris",
            Language::Ini => "Ini",
            Language::J => "J",
            Language::Json => "JSON",
            Language::Java => "Java",
            Language::JavaScript => "JavaScript",
            Language::JavaScriptReact => "JavaScriptReact",
            Language::Jsonnet => "Jsonnet",
            Language::Julia => "Julia",
            Language::Justfile => "Justfile",
            Language::Kotlin => "Kotlin",
            Language::LaTeX => "LaTeX",
            Language::Lean => "Lean",
            Language::Less => "Less",
            Language::Lua => "Lua",
            Language::Luau => "Luau",
            Language::Makefile => "Makefile",
            Language::Markdown => "Markdown",
            Language::Matlab => "Matlab",
            Language::Nickel => "Nickel",
            Language::Nix => "Nix",
            Language::OCaml => "OCaml",
            Language::ObjectiveC => "Objective_C",
            Language::ObjectiveCpp => "Objective_CPP",
            Language::Pascal => "Pascal",
            Language::Php => "PHP",
            Language::Plsql => "PLSQL",
            Language::Perl => "Perl",
            Language::PowerShell => "PowerShell",
            Language::Prolog => "Prolog",
            Language::Protobuf => "Protobuf",
            Language::Python => "Python",
            Language::R => "R",
            Language::Racket => "Racket",
            Language::Raku => "Raku",
            Language::Razor => "Razor",
            Language::Repro => "Repro",
            Language::ReSt => "ReST",
            Language::Ruby => "Ruby",
            Language::Rust => "Rust",
            Language::Sas => "SAS",
            Language::Scss => "SCSS",
            Language::Sml => "SML",
            Language::Sql => "SQL",
            Language::Sass => "Sass",
            Language::Scala => "Scala",
            Language::Scheme => "Scheme",
            Language::ShellScript => "ShellScript",
            Language::Skylark => "Skylark",
            Language::Slang => "Slang",
            Language::Solidity => "Solidity",
            Language::Svelte => "Svelte",
            Language::Swift => "Swift",
            Language::Tcl => "Tcl",
            Language::Toml => "TOML",
            Language::TeX => "TeX",
            Language::Thrift => "Thrift",
            Language::TypeScript => "TypeScript",
            Language::TypeScriptReact => "TypeScriptReact",
            Language::Verilog => "Verilog",
            Language::Vhdl => "VHDL",
            Language::VisualBasic => "VisualBasic",
            Language::Vue => "Vue",
            Language::Wolfram => "Wolfram",
            Language::Xml => "XML",
            Language::Xsl => "XSL",
            Language::Yaml => "YAML",
            Language::Zig => "Zig",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UnspecifiedLanguage" => Some(Self::UnspecifiedLanguage),
            "ABAP" => Some(Self::Abap),
            "Apex" => Some(Self::Apex),
            "APL" => Some(Self::Apl),
            "Ada" => Some(Self::Ada),
            "Agda" => Some(Self::Agda),
            "AsciiDoc" => Some(Self::AsciiDoc),
            "Assembly" => Some(Self::Assembly),
            "Awk" => Some(Self::Awk),
            "Bat" => Some(Self::Bat),
            "BibTeX" => Some(Self::BibTeX),
            "C" => Some(Self::C),
            "COBOL" => Some(Self::Cobol),
            "CPP" => Some(Self::Cpp),
            "CSS" => Some(Self::Css),
            "CSharp" => Some(Self::CSharp),
            "Clojure" => Some(Self::Clojure),
            "Coffeescript" => Some(Self::Coffeescript),
            "CommonLisp" => Some(Self::CommonLisp),
            "Coq" => Some(Self::Coq),
            "CUDA" => Some(Self::Cuda),
            "Dart" => Some(Self::Dart),
            "Delphi" => Some(Self::Delphi),
            "Diff" => Some(Self::Diff),
            "Dockerfile" => Some(Self::Dockerfile),
            "Dyalog" => Some(Self::Dyalog),
            "Elixir" => Some(Self::Elixir),
            "Erlang" => Some(Self::Erlang),
            "FSharp" => Some(Self::FSharp),
            "Fish" => Some(Self::Fish),
            "Flow" => Some(Self::Flow),
            "Fortran" => Some(Self::Fortran),
            "Git_Commit" => Some(Self::GitCommit),
            "Git_Config" => Some(Self::GitConfig),
            "Git_Rebase" => Some(Self::GitRebase),
            "Go" => Some(Self::Go),
            "GraphQL" => Some(Self::GraphQl),
            "Groovy" => Some(Self::Groovy),
            "HTML" => Some(Self::Html),
            "Hack" => Some(Self::Hack),
            "Handlebars" => Some(Self::Handlebars),
            "Haskell" => Some(Self::Haskell),
            "Idris" => Some(Self::Idris),
            "Ini" => Some(Self::Ini),
            "J" => Some(Self::J),
            "JSON" => Some(Self::Json),
            "Java" => Some(Self::Java),
            "JavaScript" => Some(Self::JavaScript),
            "JavaScriptReact" => Some(Self::JavaScriptReact),
            "Jsonnet" => Some(Self::Jsonnet),
            "Julia" => Some(Self::Julia),
            "Justfile" => Some(Self::Justfile),
            "Kotlin" => Some(Self::Kotlin),
            "LaTeX" => Some(Self::LaTeX),
            "Lean" => Some(Self::Lean),
            "Less" => Some(Self::Less),
            "Lua" => Some(Self::Lua),
            "Luau" => Some(Self::Luau),
            "Makefile" => Some(Self::Makefile),
            "Markdown" => Some(Self::Markdown),
            "Matlab" => Some(Self::Matlab),
            "Nickel" => Some(Self::Nickel),
            "Nix" => Some(Self::Nix),
            "OCaml" => Some(Self::OCaml),
            "Objective_C" => Some(Self::ObjectiveC),
            "Objective_CPP" => Some(Self::ObjectiveCpp),
            "Pascal" => Some(Self::Pascal),
            "PHP" => Some(Self::Php),
            "PLSQL" => Some(Self::Plsql),
            "Perl" => Some(Self::Perl),
            "PowerShell" => Some(Self::PowerShell),
            "Prolog" => Some(Self::Prolog),
            "Protobuf" => Some(Self::Protobuf),
            "Python" => Some(Self::Python),
            "R" => Some(Self::R),
            "Racket" => Some(Self::Racket),
            "Raku" => Some(Self::Raku),
            "Razor" => Some(Self::Razor),
            "Repro" => Some(Self::Repro),
            "ReST" => Some(Self::ReSt),
            "Ruby" => Some(Self::Ruby),
            "Rust" => Some(Self::Rust),
            "SAS" => Some(Self::Sas),
            "SCSS" => Some(Self::Scss),
            "SML" => Some(Self::Sml),
            "SQL" => Some(Self::Sql),
            "Sass" => Some(Self::Sass),
            "Scala" => Some(Self::Scala),
            "Scheme" => Some(Self::Scheme),
            "ShellScript" => Some(Self::ShellScript),
            "Skylark" => Some(Self::Skylark),
            "Slang" => Some(Self::Slang),
            "Solidity" => Some(Self::Solidity),
            "Svelte" => Some(Self::Svelte),
            "Swift" => Some(Self::Swift),
            "Tcl" => Some(Self::Tcl),
            "TOML" => Some(Self::Toml),
            "TeX" => Some(Self::TeX),
            "Thrift" => Some(Self::Thrift),
            "TypeScript" => Some(Self::TypeScript),
            "TypeScriptReact" => Some(Self::TypeScriptReact),
            "Verilog" => Some(Self::Verilog),
            "VHDL" => Some(Self::Vhdl),
            "VisualBasic" => Some(Self::VisualBasic),
            "Vue" => Some(Self::Vue),
            "Wolfram" => Some(Self::Wolfram),
            "XML" => Some(Self::Xml),
            "XSL" => Some(Self::Xsl),
            "YAML" => Some(Self::Yaml),
            "Zig" => Some(Self::Zig),
            _ => None,
        }
    }
}
